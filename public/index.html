<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Multiuser Sketchpad 2020</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      html {
        touch-action: none;
      }
      body {
        background: #ffffff;
        font-size: 10px;
        font-family: sans-serif;
        margin: 0;
        overflow: hidden;
      }
      #canvas {
        display: block;
        cursor: crosshair;
      }
      #cursors {
        position: absolute;
        width: 100%;
        height: 100%;
        overflow: hidden;
        pointer-events: none;
      }
      #menu {
        position: absolute;
        left: calc(50% - 70px);
        bottom: 10px;
        color: #808080;
        padding: 6px 10px;
        border-radius: 25px;
        vertical-align: middle;
        background-color: rgba(255,255,255,1);
        user-select: none;
      }
      #color {
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <div id="menu">
      STATUS <span id="status" style="margin-left:2px;margin-right:8px">üü°</span>
      COLOR <span id="color" style="margin-left:2px;">‚ö´Ô∏è</span>
    </div>
    <div id="cursors"></div>
    <script type="module">
      
      /**
       * Multiuser Skecthpad 2020 (COVID-19 edition)
       * 
       * Seeing that the only solution to fight COVID-19 is to stay
       * home, I thought it would be a good idea to bring this project
       * back and help stay connected somehow.
       *
       * Dev notes:
       *
       * This is a rework of a websockets experiment I did back in 2010:
       * https://experiments.withgoogle.com/multiuser-sketchpad
       *
       * Back then browsers didn't yet support binary websockets so it
       * turned out to be a bit expensive to maintain and I had to shut
       * it down.
       *
       * 10 years later, most browsers support binary websockets and
       * pointer events so making this was fairly straighforward.
       *
       * The part that took time was defining the data packets which
       * ended up being a bit like a video codec. Most of the events
       * are delta positions so it amounts 4 bytes per packet.
       *
       * Seems like most of the people are interested in the server.js
       * file, but imho the interesting one is Recorder.js and Client.js
       *
       * Hope people can use the con to see more realtime multiuser webapps.
       *
       * Stay safe!
       * - Mr.doob
       */
      
      import { Client } from './js/Client.js';
      import { Recorder } from './js/Recorder.js';

      let colorButton = document.getElementById( 'color' );
      
      // Canvas
      
      const canvas = document.createElement( 'canvas' );
      canvas.id = 'canvas';
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      document.body.appendChild( canvas );
      
      const context = canvas.getContext( '2d' );
      context.lineWidth = 0.5 * window.devicePixelRatio;
      context.fillStyle = '#eeeeee';
      context.fillRect( 0, 0, canvas.width, canvas.height );

      //
      
      let clients = {};
      let recorder = null;
      let isPointerDown = false;
      
      // WebSockets
            
      const ws = new WebSocket( 'wss://' + window.location.hostname );
      ws.binaryType = 'arraybuffer';

      ws.addEventListener( 'open', function ( event ) {

        recorder = new Recorder( context );

        canvas.addEventListener( 'pointermove', onPointerMove );
        canvas.addEventListener( 'pointerdown', onPointerDown );
        canvas.addEventListener( 'pointerup', onPointerUp );
              
        colorButton.addEventListener( 'click', onColorClick );

        document.getElementById( 'status' ).textContent = 'üü¢';    

      } );

      ws.addEventListener( 'close', function ( event ) {

        recorder = null;

        canvas.removeEventListener( 'pointermove', onPointerMove );
        canvas.removeEventListener( 'pointerdown', onPointerDown );
        canvas.removeEventListener( 'pointerup', onPointerUp );
        
        document.getElementById( 'status' ).textContent = 'üî¥';

      } );

      ws.addEventListener( 'message', function ( event ) {

        let dataview = new DataView( event.data );
        let id = dataview.getUint8( 0 );
      
        if ( clients[ id ] === undefined ) {
          
          let container = document.getElementById( 'cursors' );
          clients[ id ] = new Client( context, container );
          
        }
        
        clients[ id ].execute( dataview );

      } );
      
      // It's 2020 and WebKit/iOS still needs this...

      canvas.addEventListener( 'touchstart', function ( event ) {
        
        event.preventDefault();
              
      } );
      
      
      // Menu
      
      let color = 0;
      let colors = [ '‚ö´Ô∏è', 'üîµ', 'üî¥', 'üü£', '‚ö™Ô∏è' ];
      
      function onColorClick() {

        color = ( color + 1 ) % colors.length;
        colorButton.textContent = colors[ color ];
        
        recorder.color( color );

      }
      
      // Recorder
      
      let ptime = 0;
      
      function onPointerMove( event ) {
        
        event.preventDefault();

        // Throttle to 30Hz

        const throttle = ( 1 / 30 ) * 1000;
        const time = event.timeStamp;

        if ( time < ( ptime + throttle ) ) return;

        ptime = time;

        //
        
        if ( isPointerDown ) {

          const x = parseInt( event.pageX * window.devicePixelRatio );
          const y = parseInt( event.pageY * window.devicePixelRatio );

          ws.send( recorder.move( x, y ) );

        }

      }
      
      function onPointerDown( even ) {
        
        isPointerDown = true;

        const x = parseInt( event.pageX * window.devicePixelRatio );
        const y = parseInt( event.pageY * window.devicePixelRatio );

        ws.send( recorder.down( x, y ) );
        
      }
      
      function onPointerUp( event ) {
        
        isPointerDown = false;
        
        ws.send( recorder.up() );
        
      }
      
    </script>
  </body>
</html>

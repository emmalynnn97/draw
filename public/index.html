<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Multiuser Sketchpad 2020</title>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link type="text/css" rel="stylesheet" href="./css/main.css">
  </head>
  <body>
    <div id="menu">
      STATUS <span id="status" style="margin-left:2px;margin-right:8px">üü°</span>
      COLOR <span id="color" style="margin-left:2px;">‚ö´Ô∏è</span>
    </div>
    <div id="cursors"></div>
    <script type="module">
      
      /**
       * Multiuser Sketchpad 2020 (COVID-19 edition)
       * 
       * Seeing that the only solution to fight COVID-19 is to stay
       * home, I thought it would be a good idea to bring this project
       * back and help people stay connected somehow.
       *
       * Dev notes:
       *
       * This is a rework of a websockets experiment I did back in 2010:
       * https://experiments.withgoogle.com/multiuser-sketchpad
       *
       * Back then browsers didn't support binary websockets yet so it
       * turned out to be a bit expensive to maintain and I had to shut
       * it down.
       *
       * 10 years later, most browsers support binary websockets and
       * pointer events so making this was fairly straighforward.
       *
       * The part that took time was defining the data packets (which
       * ended up being a bit like a video codec). Most of the events
       * being sent are delta positions so the average packet size is
       * 4 bytes.
       *
       * Seems like people are mostly interested in the server.js file
       * but imho the interesting ones are Recorder.js and Client.js.
       *
       * Hope to see people remixing this so we can start seeing more
       * multiuser realtime sites!
       *
       * Stay safe.
       * - Mr.doob
       */
      
      import { Client } from './js/Client.js';
      import { Recorder } from './js/Recorder.js';

      let colorButton = document.getElementById( 'color' );
      
      // Canvas
      
      const canvas = document.createElement( 'canvas' );
      canvas.id = 'canvas';
      canvas.width = window.innerWidth * window.devicePixelRatio;
      canvas.height = window.innerHeight * window.devicePixelRatio;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
      document.body.appendChild( canvas );
      
      const context = canvas.getContext( '2d' );
      context.lineWidth = 0.7 * window.devicePixelRatio;
      context.fillStyle = '#eeeeee';
      context.fillRect( 0, 0, canvas.width, canvas.height );

      //
      
      let clients = {};
      let recorder = null;
      let isPointerDown = false;
      
      // WebSockets
            
      const ws = new WebSocket( 'wss://' + window.location.hostname );
      ws.binaryType = 'arraybuffer';

      ws.addEventListener( 'open', function ( event ) {

        recorder = new Recorder( context );

        canvas.addEventListener( 'pointermove', onPointerMove );
        canvas.addEventListener( 'pointerdown', onPointerDown );
        canvas.addEventListener( 'pointerup', onPointerUp );
              
        colorButton.addEventListener( 'click', onColorClick );

        document.getElementById( 'status' ).textContent = 'üü¢';    

      } );

      ws.addEventListener( 'close', function ( event ) {

        recorder = null;

        canvas.removeEventListener( 'pointermove', onPointerMove );
        canvas.removeEventListener( 'pointerdown', onPointerDown );
        canvas.removeEventListener( 'pointerup', onPointerUp );
        
        document.getElementById( 'status' ).textContent = 'üî¥';

      } );

      ws.addEventListener( 'message', function ( event ) {

        let dataview = new DataView( event.data );
        let id = dataview.getUint8( 0 );
      
        if ( clients[ id ] === undefined ) {
          
          let container = document.getElementById( 'cursors' );
          clients[ id ] = new Client( context, container );
          
        }
        
        clients[ id ].execute( dataview );

      } );
      
      // It's 2020 and WebKit/iOS still needs this...

      canvas.addEventListener( 'touchstart', function ( event ) {
        
        event.preventDefault();
              
      } );
      
      
      // Menu
      
      let color = 0;
      let colors = [ '‚ö´Ô∏è', 'üîµ', 'üî¥', 'üü£', '‚ö™Ô∏è' ];
      
      function onColorClick() {

        color = ( color + 1 ) % colors.length;
        colorButton.textContent = colors[ color ];
        
        recorder.color( color );

      }
      
      // Recorder
      
      let ptime = 0;
      
      function onPointerMove( event ) {
        
        event.preventDefault();

        if ( isPointerDown ) {

          // Throttle to 30Hz

          const throttle = ( 1 / 30 ) * 1000;
          const time = event.timeStamp;

          if ( time < ( ptime + throttle ) ) return;

          ptime = time;

          //        

          const x = parseInt( event.pageX * window.devicePixelRatio );
          const y = parseInt( event.pageY * window.devicePixelRatio );

          ws.send( recorder.move( x, y ) );

        }

      }
      
      function onPointerDown( even ) {
        
        isPointerDown = true;

        const x = parseInt( event.pageX * window.devicePixelRatio );
        const y = parseInt( event.pageY * window.devicePixelRatio );

        ws.send( recorder.down( x, y ) );
        
      }
      
      function onPointerUp( event ) {
        
        isPointerDown = false;
        
        ws.send( recorder.up() );
        
      }
      
    </script>
  </body>
</html>
